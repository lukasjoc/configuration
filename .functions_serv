#!/bin/bash

# Message on SHELL start
figlet "Hello, $USER" || echo "Hello, $USER"
neofetch || true
fortune || true
##########

# list docker info neatly and with color
cooldocker() {

        local ic nc vc cc

        cc=$(docker container ls -aq | wc -l | sed 's/ //g')
        echo -e "\n[ \e[36m$cc\e[0m ] | CONTAINERS:"
        docker container ls | while read -r line; do
                if echo "$line" | grep -q "CONTAINER ID"; then
                echo -e "$line\t IP ADDRESS"
                else
                        cid=$(echo "$line" | awk '{print $1}');
                        cip=$(docker inspect -f "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}" "$cid");
                echo -e "${line}\t${cip}\n\n"
          fi
        done

        ic=$(docker images -q | wc -l | sed 's/ //g' ) 
        echo -e "[ \e[36m$ic\e[0m ] | IMAGES:"
        docker images && echo

        nc=$(docker network ls -q | wc -l | sed 's/ //g')
        echo -e "[ \e[36m$nc\e[0m ] | NETS:"
        docker network ls && echo

        vc=$(docker volume ls -q | wc -l | sed 's/ //g')
        if [ "$vc" -ge 1 ]; then
                echo -e "[ \e[36m$vc\e[0m ] | VOLUMES:"
                docker volume ls && echo
        fi

}

# stop, remove all containers, images, volumes, networks
killdocker() {
        docker stop "$(docker container ls -aq)"
        docker rm "$(docker container ls -aq)"
        docker volume prune -f
        docker network prune -f
        docker rmi "$(docker images -aq)"
}

# get current status of git repo
# SRC: http://ezprompt.net/
parse_git_dirty() {
        local status untracked ahead newfile renamed deleted bits
        status=$(git status 2>&1 | tee)
        dirty=$(echo -n "${status}" 2>/dev/null | grep "modified:" &>/dev/null; echo "$?")
        untracked=$(echo -n "${status}" 2>/dev/null | grep "Untracked files" &>/dev/null; echo "$?")
        ahead=$(echo -n "${status}" 2>/dev/null | grep "Your branch is ahead of" &>/dev/null; echo "$?")
        newfile=$(echo -n "${status}" 2>/dev/null | grep "new file:" &>/dev/null; echo "$?")
        renamed=$(echo -n "${status}" 2>/dev/null | grep "renamed:" &>/dev/null; echo "$?")
        deleted=$(echo -n "${status}" 2>/dev/null | grep "deleted:" &>/dev/null; echo "$?")
        bits=''

        if [ "${renamed}" == "0" ]; then
                bits="+-${bits}"
        fi
        if [ "${ahead}" == "0" ]; then
                bits="^${bits}"
        fi
        if [ "${newfile}" == "0" ]; then
                bits="++${bits}"
        fi
        if [ "${untracked}" == "0" ]; then
                bits="*${bits}"
        fi
        if [ "${deleted}" == "0" ]; then
                bits="-${bits}"
        fi
        if [ "${dirty}" == "0" ]; then
                bits="*${bits}"
        fi
        if [ ! "${bits}" == "" ]; then
                echo " ${bits}"
        else
                echo ""
        fi

}


# get current branch in git repo
# SRC: http://ezprompt.net/
parse_git_branch() {
        branch=$(git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
        if [ -n "${branch}" ]; then
                local stat
                stat=$(parse_git_dirty)
                echo "(${branch}${stat}) $ "
        else
                echo ""
        fi
}

# quick alias to cd into working dir
fun() {
        cd "$ENVM_WDIR" || return
}

# quick alias to cd into working dir
fn() {
        cd "$ENVM_WDIR" || return
}

# reload $SHELL with -
ns() {
        exec "$SHELL" -l
}

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

# Setup promt like this: (user)::(hostname) (PWD)$ ((branch) (status))
export PS1="\[\e[1;32m\]\u\[\e[m\]::\[\e[1;31m\]\h\[\e[m\] \[\e[1;10m\]\W\[\e[m\]\\$ \[\e[1;36m\]\`parse_git_branch\`\[\e[m\]"
